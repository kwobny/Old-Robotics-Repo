/*
 *   Created by Adam Sher on 11/4/18
 *   This class will be used for the robot to control itself during the autonomous period.
 *   This autonomous will be used when the robot is placed on one of the two crater corners.
 */


package org.firstinspires.ftc.teamcode.OpModes.Autonomous;

import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.util.Range;

import org.firstinspires.ftc.teamcode.Other.Backend.MadHardware;
import org.firstinspires.ftc.teamcode.Other.Backend.MotorControl;
import java.lang.Override;



@Autonomous(name = "Auto 1819: Crater", group = "Autos")   // How opmode is displayed on phones
public class MainAutonomousCrater extends LinearOpMode
{


    // Initializing the motor-control class.
    private MotorControl mc = new MotorControl();
    private MadHardware mhw = new MadHardware();
    public ElapsedTime runtime = new ElapsedTime();

    public boolean yeet = false;


    // This method is run once when the "INIT" button is pressed on the phone.
    @Override
    public void runOpMode()
    {
        // addData calls are used for debugging.
        telemetry.addData("Status", "Initializing...");

        // Ensure that the motors are not accidentally enabled when opmode is off. Prevents crashes.
        mc.opModeOff();

        // Initialize motor controller (effectively calling MadHardware.init())
        mc.initialize(hardwareMap);

        telemetry.addData("Status", "Initialized, awaiting autonomous start.");



        waitForStart();



        // Allow motors to function.
        mc.opModeOn();

        telemetry.addData("Status", "Autonomous start successful.");



        // [INSERT DRIVING CODE HERE]

        mc.doDriving(true, false, 1.0f, 2.0f);

        /*
        // Here, we must attempt to capture the gold cube, move to the other
        // side to deploy the marker, and return to enter the crater.
        mc.doDriving(true, true, 0.3f, 0.5f);  // Move forward
        mc.doDriving(false, false,  1.0f, 0.3f);  // Turn left 30*
        mc.executeTurn(-0.3f, 330);
        mc.doDriving(true, true, 0.3f, 2.0f);  // Move forward
        mc.executeServo("gate", false, 0.3f, 0.5f);  // Close gate
        mc.doDriving(false, false, 1.0f, 1.0f);  // Turn left 90*
        mc.executeTurn(-0.3f, 255);
        mc.doDriving(true, true, 0.3f, 5.5f);  // Move forward
        mc.doDriving(false, true, 1.0f, 1.2f);  // Turn right 110*
        mc.executeTurn(0.3f, 110);
        mc.executeServo("yeeter", true, 1.0f, 1.0f);  // Yeet
        mc.doDriving(false, false, 1.0f, 1.2f);  // Turn left 110*
        mc.executeTurn(-0.3f, 250);
        mc.doDriving(true, false, 0.3f, 5.5f);  // Move backward
        mc.doDriving(true, false,1.0f, 1.0f);  // Move backward faster
        */

        // [STOP DRIVING CODE]



        telemetry.addData("Status", "Autonomous complete.");

        mc.opModeOff();

        telemetry.addData("Status", "Autonomous complete, awaiting autonomous stop.");

        sleep(1000);
    }


} // End of class