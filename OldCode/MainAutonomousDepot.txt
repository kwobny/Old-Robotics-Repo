/*
 *   Created by Adam Sher on 11/4/18
 *   This class will be used for the robot to control itself during the autonomous period.
 *   This autonomous will be used when the robot is placed on one of the two depot corners.
 */


package org.firstinspires.ftc.teamcode.OpModes.Autonomous;

import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.util.Range;

import org.firstinspires.ftc.teamcode.Other.Backend.MadHardware;
import org.firstinspires.ftc.teamcode.Other.Backend.MotorControl;
import java.lang.Override;



@Autonomous(name = "Auto 1819: Depot", group = "Autos")   // How opmode is displayed on phones
public class MainAutonomousDepot extends LinearOpMode
{


	// Initializing the motor-control class.
	private MotorControl mc = new MotorControl();
    private MadHardware mhw = new MadHardware();
    public ElapsedTime runtime = new ElapsedTime();

	public boolean yeet = false;


	// This method is run once when the "INIT" button is pressed on the phone.
	@Override
	public void runOpMode()
	{
		// addData calls are used for debugging.
		telemetry.addData("Status", "Initializing...");

		// Ensure that the motors are not accidentally enabled when opmode is off. Prevents crashes.
		mc.opModeOff();

		// Initialize motor controller (effectively calling MadHardware.init())
		mc.initialize(hardwareMap);

		telemetry.addData("Status", "Initialized, awaiting autonomous start.");



		waitForStart();



		// Allow motors to function.
		mc.opModeOn();

		telemetry.addData("Status", "Autonomous start successful.");



		// [INSERT DRIVING CODE HERE]

		// Here, we must attempt to capture the gold cube, deploy the marker, and enter the crater.

		mc.doDriving(true, true,  0.3f, 1.75f);  // Move forward
        //if(mhw.colorSensor.alpha() > 17);
		mc.executeTurn(0.3f, 75);
		mc.executeServo("yeeter", false, 1.0f, 1.0f);  // Yeet

		/*
		mc.executeTurn(-0.3f, 0);
		mc.doDriving(true, true, 0.3f, 1.0f);
		mc.executeTurn(-0.3f, 290);
		mc.doDriving(true, false, 0.3f, 4.0f);  // Move backward
		mc.doDriving(true, false, 1.0f, 1.0f);  // Move backward faster
		*/

		// [STOP DRIVING CODE]



		telemetry.addData("Status", "Autonomous complete.");

		mc.opModeOff();

		telemetry.addData("Status", "Autonomous complete, awaiting autonomous stop.");

		sleep(1000);
	}


} // End of class