/*
*   Created by Adam Sher on 11/6/18
*   This class will be used as an interface for interacting with the driving motors.
 */

package org.firstinspires.ftc.teamcode.Other.Backend;

import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.HardwareMap;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.util.ElapsedTime;
import org.firstinspires.ftc.teamcode.Other.Backend.MadHardware;

public class MotorControl
{

    // Declare necessary objects.
    private MadHardware mhw = new MadHardware();
    private ElapsedTime runtime = new ElapsedTime();

    // This variable will be used as a substitute for opModeIsActive() checks.
    public boolean opModeIsActive = false;



    // This method is used to initialize the MadHardware object.
    public void initialize(HardwareMap hwMap)
    {
        mhw.init(hwMap);

    }



    // These methods will be used by other classes so this one knows
    // whether the current opmode is active or not.
    public void opModeOn()
    {
        opModeIsActive = true;

    }
    public void opModeOff()
    {
        opModeIsActive = false;

    }





    // This method will be used as a pass-through to the doComplexDriving method, and
    // accepts fewer parameters.
    public void doDriving(boolean linearMovement, boolean direction, float movementSpeed, float duration)
    {
        // Set the default values to be given to doComplexDriving. They effectively
        // disable drift and acceleration.
        boolean DEFAULT_DRIFT = false;
        boolean DEFAULT_ACCELERATION_IS_ADDED = true;
        float DEFAULT_ACCELERATION_TIME = 0f;
        boolean DEFAULT_RETURN_TO_ZERO = true;

        // Send values to doComplexDriving.
        doComplexDriving(linearMovement, direction, movementSpeed, duration, DEFAULT_DRIFT, DEFAULT_ACCELERATION_IS_ADDED, DEFAULT_ACCELERATION_TIME, DEFAULT_RETURN_TO_ZERO);
    }







    // This method will be used to interface with the motors without having to write
    // multiple conditional statements or loops later down the road.
    // linearMovement: true=straight       false = turn
    // direction:      true=forward/right  false = backward/left
    // drift:          true=continue       false = stop
    // movementSpeed:  0.0f=0% power       1.0=100% power
    // duration is time in seconds.
    public void doComplexDriving(boolean linearMovement, boolean direction, float movementSpeed, float duration, boolean drift, boolean accelerationIsAdded, float accelerationTime, boolean returntoZero)
    {
        // Set initial powers to zero so it will not crash if controllers are not plugged in.
        float targetPowerLeft = 0f;
        float targetPowerRight = 0f;

        movementSpeed *= -1;

        // This block of nested if-statements will determine which direction each motor must move.
        if(linearMovement) // Move straight
        {
            if(direction)
            {
                // Move forward
                targetPowerLeft = movementSpeed;
                targetPowerRight = movementSpeed;
            }
            else
            {
                // Move backward
                targetPowerLeft = -movementSpeed;
                targetPowerRight = -movementSpeed;
            }
        }
        else // Turn
            if(direction)
            {
                // Turn clockwise (to the right)
                targetPowerLeft = movementSpeed;
                targetPowerRight = -movementSpeed;
            }
            else
            {
                // Turn counter-clockwise (to the left)
                targetPowerLeft = -movementSpeed;
                targetPowerRight = movementSpeed;
            }


        // Send these values to the executeDriving method.
        executeDriving(targetPowerLeft, targetPowerRight, duration, drift, accelerationIsAdded, accelerationTime, returntoZero);

    } // End of doDriving method






    // This method will be used to set the motors to the correct speeds.
    public void executeDriving(float targetPowerLeft, float targetPowerRight, float duration, boolean drift, boolean accelerationIsAdded, float accelerationTime, boolean returntoZero)
    {
        // Save the initial powers of the motors and the differences between the
        // target powers and initial powers into variables.
        float deltaPowerLeftInitial = targetPowerLeft - (float)mhw.leftDrive.getPower();
        float powerLeftInitial = (float)mhw.leftDrive.getPower();
        float deltaPowerRightInitial = targetPowerRight - (float)mhw.rightDrive.getPower();
        float powerRightInitial = (float)mhw.rightDrive.getPower();


        // Reset tracking time.
        runtime.reset();

        // This loop will slowly move to the target powers over the acceleration period.
        while(opModeIsActive && (runtime.time() < accelerationTime) && accelerationTime != 0f)
        {
            // Difference in power between power to change to and initial =
            // the total difference * the fraction of the acceleration time passed.
            float deltaPowerLeftCurrent = deltaPowerLeftInitial * ((float)runtime.seconds() / accelerationTime);
            float deltaPowerRightCurrent = deltaPowerRightInitial * ((float)runtime.seconds() / accelerationTime);

            // Set powers to the initial powers plus the change in power.
            mhw.leftDrive.setPower(powerLeftInitial + deltaPowerLeftCurrent);
            mhw.rightDrive.setPower(powerRightInitial + deltaPowerRightCurrent);

        }

        if (opModeIsActive)
        {
            // Set powers to the target powers. This is used when there is no
            // acceleration and to get exact values.
            mhw.leftDrive.setPower(targetPowerLeft);
            mhw.rightDrive.setPower(targetPowerRight);
        }



        // Run motors for given duration.
        runtime.reset();
        // If extra time is given to acceleration, move for the duration.
        if(accelerationIsAdded)
        {
            while(opModeIsActive && (runtime.time() < duration))
                if(false)
                    mhw.leftDrive.setPower(0f);
        }
        else // If extra time is not given
        {
            if(drift) // If we are going to drift, only initial acceleration is subtracted.
            {
                while(opModeIsActive && (runtime.time() < (duration - accelerationTime)))
                    if (true) {
                        mhw.leftDrive.setPower(targetPowerLeft);
                        mhw.rightDrive.setPower(targetPowerRight);
                    }
            }
            else // If we are not drifting, both acceleration times are subtracted.
            {
                while(opModeIsActive && (runtime.time() < (duration - (2 * accelerationTime))))
                    if (true) {
                        mhw.leftDrive.setPower(targetPowerLeft);
                        mhw.rightDrive.setPower(targetPowerRight);
                    }
            }
        }


        // If we are drifting, stay at current speed.
        if(drift)
            return;
        else // If not drifting, call this method with 0 for all values, stopping robot.
        {
            if ((Math.abs(mhw.leftDrive.getPower()) >= 0.01 || Math.abs(mhw.rightDrive.getPower()) >= 0.01) && returntoZero)
            {
                executeDriving(0f, 0f, 0f, false, true, accelerationTime, false);
                return;
            }
        }


    } // End of executeDriving method



    public void executeTurn(float power, float targetAngle)
    {
        /*
        float currentAngle = mhw.gyro.getHeading();

        if(targetAngle >= 0)
            power *= -1;

        if(targetAngle + currentAngle >= 360)
            currentAngle -= 360;
        else if(targetAngle + currentAngle <= 0)
            currentAngle += 360;

        while(Math.abs((targetAngle + currentAngle) - mhw.gyro.getHeading()) >= 5 && opModeIsActive)
        {
            mhw.leftDrive.setPower(power);
            mhw.rightDrive.setPower(-power);
        }

        mhw.leftDrive.setPower(0);
        mhw.rightDrive.setPower(0);
        */

        mhw.gyro.calibrate();

        while(mhw.gyro.isCalibrating())
        {
            mhw.leftDrive.setPower(0);
            mhw.rightDrive.setPower(0);
        }

        while(Math.abs(targetAngle - mhw.gyro.getHeading()) > 5 && opModeIsActive)
        {
            mhw.leftDrive.setPower(-power);
            mhw.rightDrive.setPower(power);
        }
        mhw.leftDrive.setPower(0);
        mhw.rightDrive.setPower(0);
    }


    public String executeServo(String servoName, boolean direction, float power, float duration)
    {
        if (!direction)
            power *= -1;


        if (servoName.equalsIgnoreCase("releaser"))
        {
            mhw.releaserServo.setPower(power);
            runtime.reset();
            while(runtime.seconds() < duration && opModeIsActive)
            {
                mhw.releaserServo.setPower(power);
            }
            mhw.releaserServo.setPower(0f);
            return("Moved release servo.");
        }
        else if (servoName.equalsIgnoreCase("yeeter"))
        {
            mhw.yeeterServo.setPower(power);
            runtime.reset();
            while(runtime.seconds() < duration && opModeIsActive)
            {
                mhw.yeeterServo.setPower(power);
            }
            mhw.yeeterServo.setPower(0f);
            return("Moved yeeter servo.");
        }
        else if (servoName.equalsIgnoreCase("gate"))
        {
            mhw.gateServo.setPower(power);
            runtime.reset();
            while(runtime.seconds() < duration && opModeIsActive)
            {
                mhw.gateServo.setPower(power);
            }
            mhw.gateServo.setPower(0f);
            return("Moved gate servo.");
        }
        else
        {
            return("ERROR: Invalid Servo!");
        }
    }




    public String executeMotor(String motorName, boolean direction, float power, float duration)
    {
        if (!direction)
            power *= -1;


        if (motorName.equalsIgnoreCase("lifter"))
        {
            mhw.lifterMotor.setPower(power);
            runtime.reset();
            while(runtime.time() < duration && opModeIsActive)
            {
                mhw.lifterMotor.setPower(power);
            }
            mhw.lifterMotor.setPower(0f);
            return("Moved lifter motor.");
        }
        else if (motorName.equalsIgnoreCase("harvester"))
        {
            mhw.harvesterMotor.setPower(power);
            runtime.reset();
            while(runtime.time() < duration && opModeIsActive)
            {
                mhw.harvesterMotor.setPower(power);
            }
            mhw.harvesterMotor.setPower(0f);
            return("Moved harvester motor.");
        }
        else if(motorName.equalsIgnoreCase("hanger"))
        {
            mhw.hangerMotor.setPower(power);
            runtime.reset();
            while(runtime.time() < duration && opModeIsActive)
            {
                mhw.harvesterMotor.setPower(power);
            }
            mhw.harvesterMotor.setPower(0f);
            return("Moved hanger motor.");
        }
        else
        {
            return("ERROR: Invalid Motor!");
        }
    }

    public void waitPls(float duration)
    {
        runtime.reset();
        while(runtime.time() < duration && opModeIsActive) {
            mhw.leftDrive.setPower(mhw.leftDrive.getPower());
        }
        return;
    }


} // End of class