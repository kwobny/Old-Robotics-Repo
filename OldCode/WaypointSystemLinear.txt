/*
 *   Created by Adam Sher on 1/5/19
 *   This class will be used to control the waypoint/beacon system, allowing the robot
 *   to automatically return to a specified position.
 */

package org.firstinspires.ftc.teamcode.Other;

import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.HardwareMap;
import com.qualcomm.robotcore.util.ElapsedTime;

import org.firstinspires.ftc.teamcode.Other.Backend.MadHardware;

public class WaypointSystemLinear
{

    MadHardware mhw = new MadHardware();

    float currentRadius;
    float currentPositionX;
    float currentPositionY;
    double currentRotation;
    boolean opModeIsActive = false;

    // This method is used to initialize the MadHardware object.
    public void initialize(HardwareMap hwMap)
    {
        mhw.init(hwMap);

    }

    // These methods will be used by other classes so this one knows
    // whether the current opmode is active or not.
    public void opModeOn()
    {
        opModeIsActive = true;

    }
    public void opModeOff()
    {
        opModeIsActive = false;

    }

    public void addWaypoint()
    {
        currentRadius = 0;
        currentPositionX = 0;
        currentPositionY = 0;
        currentRotation = 0;
        // if(!hasInitialized)
        //mhw.init(hardwareMap);
    }


    public void updatePosition(double rotation, float leftDist, float rightDist)
    {
        currentRotation = 360 - rotation;
        currentPositionX += (0.5 * (leftDist + rightDist)) * Math.cos(currentRotation);
        currentPositionY += (0.5 * (leftDist + rightDist)) * Math.sin(currentRotation);
        currentRadius = (float)Math.sqrt(Math.pow(currentPositionX, 2) + Math.pow(currentPositionY, 2));
    }



    public void goToWaypoint()
    {
        if(currentRotation < Math.atan(currentPositionY / currentPositionX))
        {
            mhw.gyro.resetZAxisIntegrator();
            while(Math.abs((Math.atan(currentPositionY / currentPositionX) - currentRotation) - mhw.gyro.rawZ()) >= 0.01 && opModeIsActive)
            {
                mhw.leftDrive.setPower(-0.65);
                mhw.rightDrive.setPower(0.65f);
            }
        }
        else if(currentRotation > Math.atan(currentPositionY / currentPositionX))
        {
            mhw.gyro.resetZAxisIntegrator();
            while(Math.abs((currentRotation - Math.atan(currentPositionY / currentPositionX)) - mhw.gyro.rawZ()) >= 0.01 && opModeIsActive)
            {
                mhw.leftDrive.setPower(-0.65);
                mhw.rightDrive.setPower(0.65);
            }
        }


        mhw.gyro.resetZAxisIntegrator();
        while(Math.abs(mhw.gyro.rawZ() - 180) > 0.01 && opModeIsActive)
        {
            mhw.leftDrive.setPower(0.65);
            mhw.rightDrive.setPower(-0.65);
        }


        mhw.leftDrive.setMode(DcMotor.RunMode.RESET_ENCODERS);
        mhw.leftDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        while(Math.abs(mhw.leftDrive.getCurrentPosition() - currentRadius) > 0.01 && opModeIsActive)
        {
            mhw.leftDrive.setPower(0.65);
            mhw.rightDrive.setPower(0.65);
        }
    }
}